"This script creates bootstrapped factor scores for each year in the fitted model .rds objects
after running 2_model.R, given a specific lavaan model.

Usage: 3_bootstrap.R --original_fitted_models_path=<original_fitted_models_path> --model_file_path=<model_file_path> --path_out=<path_out> [--n | -num_samples] [--m | -multilevel]

Options:
--original_fitted_models_path=<original_fitted_models_path> A file path to the .rds objects generated by running 2_model.R.
--model_file_path=<model_file_path> A file path that describes the lavaan model to fit.
--path_out=<path_out> A file path that describes where to output the bootstrapped factor scores.
-n --num_samples An integer that describes how many bootstrap replications to fit [default: 5000].
-m --multilevel A flag, either Y or N, that describes if the lavaan model in model_file_path is meant to be multilevel [default: Y].
" -> doc

library(tidyverse)
library(lavaan)
library(parallel)
library(docopt)

opt <- docopt(doc)

#' This function extracts approximate factor scores (i.e. the latent variables)
#' from a fitted lavaan model. This is a helper function not meant to be 
#' used by itself.
#'
#' @param model A lavaan fitted model.
#' @param level If 2, return grouped estimates of latent variables 
#' (i.e. random intercept model), otherwise set to 1, which returns individual levels.
#' Will throw an error if model is not multilevel.
#' @param newdata An optional argument. If provided, factor scores are obtained for 
#' this dataset. Default = NULL.
#' @return A tibble with columns player, off_score, and def_score.
#' @export
#'
#' @examples
#' get_latent_vars(my_lavaan_model)
get_latent_vars <- function(model, newdata = NULL, level = 2) {
	
	if (all(model@Model@multilevel == FALSE & level == 2)) {
		stop("Level = 2 but the fitted model is not multilevel. Either set level = 1 or
				 fit a multilevel model.")
	} 
	
	if (level == 2) {
		
		factor_scores <- as_tibble(lavPredict(model, newdata = newdata, level = 2))
		bind_cols(player = model@Data@Lp[[1]]$cluster.id[[2]], factor_scores)
		
	} else {
		
		factor_scores <- as_tibble(lavPredict(model, newdata = newdata, level = 1))
		bind_cols(player = rep(NA, model@Data@nobs[[1]]), factor_scores)
		
	}
	
}

#' Fit a lavaan model with a given model code on a given dataset.
#'
#' @param data A bootstrap sample of original_data, as a tibble/dataframe.
#' @param original_data An optional tibble of the original dataset that `data` was
#' bootstrapped from. Default = NULL.
#' @param model_code A string describing a structural equation model.
#' @param multilevel If TRUE, fits a multilevel model. Default is TRUE. 
#' 
#' @return A list with extracted factor scores, model AIC, the actual model itself, and the data used
#' to fit the model.
#' @export
#'
#' @examples
#' fit_model_year(forward_data, my_model_code)
fit_bootstrap <- function(data, original_data = NULL, model_code, multilevel = TRUE) {
	
	if (multilevel == TRUE) {
		
		if (!is.null(original_data)) {
			stop("Multilevel models can only have factor scores returned using the original
					 dataset currently in lavaan.")
		}
		
		model <- sem(model = model_code, data = data, cluster = "player")
		scores <- get_latent_vars(model, level = 2) 
	} else {
		model <- sem(model = model_code, data = data)
		scores <- get_latent_vars(model, newdata = original_data, level = 1)
		
		if (is.null(original_data)) {
			scores <- scores %>%
				mutate(player = data$player)
		} else {
			scores <- scores %>%
				mutate(player = original_data$player)
		}
		
	}
	
	list(factor_scores = scores, aic = AIC(model), model = model, data = data)
	
}

#' Create a bootstrapped dataset from a given dataset (that takes into consideration
#' the grouped nature of the data), for a specific seed. Samples with replacement
#' amongst clusters, but samples without replacement within each cluster.
#'
#' @param seed The seed to use for sampling within each cluster.
#' @param data The data to create bootstrap replications from.
#' @param model_file The lavaan .txt file to use.
#' @param multilevel Logical TRUE/FALSE if the model is meant to be fit as a 
#' random intercept model (default = TRUE).
#'
#' @return Factor scores generated from the bootstrapped dataset.
#' @export
#'
#' @examples
#' bootstrap_replicate(
#' 123,
#' data = my_original_data,
#' model_file = my_lavaan_txt_file,
#' multilevel = TRUE
#' )
bootstrap_replicate <- function(seed, data, model_file, multilevel = TRUE) {
	
	if (multilevel == TRUE) {
		# Get all of the unique players in the dataset
		all_clusters <- unique(data$player)
		
		# Get all of the original counts, since in the event we sample more years than
		# we have available we just cap at the maximum.
		all_original_counts <- data %>%
			group_by(player) %>%
			count(name = "actual_counts")
		
		# Sample the clusters with replacement, then sample within each cluster without replacement.
		# If by chance the number of samples needed is larger than the actual number, cap at the total 
		# number of observations for that cluster in the actual dataset.
		set.seed(seed)
		sample_cluster_counts <- tibble(player = sample(all_clusters, replace = TRUE, size = nrow(data))) %>%
			group_by(player) %>%
			count(name = "sample_counts") %>%
			left_join(., all_original_counts, by = "player") %>%
			mutate(sample_counts = ifelse(sample_counts > actual_counts, actual_counts, sample_counts)) %>%
			left_join(., data, by = "player") %>%
			sample_n(size = sample_counts) %>%
			select(-sample_counts, -actual_counts)
		
		# Fit the model on the bootstrap sample. Get the factor scores, bind
		# with seed number.
		fit_bootstrap(
			sample_cluster_counts,
			model_code = model_file,
			multilevel = multilevel
		)$factor_scores %>%
			bind_cols(., seed_number = rep(seed, nrow(.)))
	
	} else {
		
		# Simple sample with replacement - no need for anything special in this case
		# if data is not grouped.
		set.seed(seed)
		sample_cluster_counts <- data %>%
			sample_n(size = nrow(.), replace = TRUE)
		
		
		# Fit the model on the bootstrap sample. Get the factor scores, bind
		# with seed number.
		fit_bootstrap(
			sample_cluster_counts,
			original_data = data,
			model_code = model_file,
			multilevel = multilevel
		)$factor_scores %>%
			bind_cols(., seed_number = rep(seed, nrow(.)))
		
	}
	
}

main <- function(original_fitted_models_path, model_file_path, path_out, num_samples, multilevel) {

	# Initialize objects
	multilevel_temp <- ifelse(multilevel == "Y", TRUE, FALSE)
	all_original_models <- read_rds(original_fitted_models_path)
	start_year <- as.numeric(names(all_original_models)[1]) - 1
	all_years_bootstrap <- vector("list", length(all_original_models))
	model_file <- read_file(model_file_path)
	
	# If path_out doesn't exist, create it.
	if (!dir.exists(path_out)) {
		dir.create(path_out, recursive = TRUE)
	}
	
	# Go through all of the years, and bootstrap in parallel. Output .rds file
	# to the output path specified in the terminal.
		for (i in seq_along(all_years_bootstrap)) {
	
			data <- all_original_models[[i]]$data
			
			writeLines(paste("Bootstrapping Year:", start_year + i, "for model file:", model_file_path))
			set.seed(200350623)
			seeds <- sample(1:1000000000, replace = FALSE, size = as.numeric(num_samples))
			all_years_bootstrap[[i]] <- mclapply(
				seeds,
				FUN = bootstrap_replicate,
				data = data,
				model_file = model_file,
				multilevel = multilevel_temp,
				mc.cores = detectCores() - 2
			) %>%
			bind_rows(.) %>%
			write_rds(paste0(path_out, "/", start_year + i, ".rds"))
	
		}

}

main(
	opt$original_fitted_models_path,
	opt$model_file_path,
	opt$path_out,
	opt$num_samples,
	opt$multilevel
)