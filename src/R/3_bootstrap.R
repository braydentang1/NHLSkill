"This script creates bootstrapped factor scores for each year in the fitted model .rds objects
after running 2_model.R, given a specific lavaan model.

Usage: 3_bootstrap.R --original_fitted_models_path=<original_fitted_models_path> --model_file_path=<model_file_path> --path_out=<path_out> [--n | -num_samples] [--m | -multilevel]

Options:
--original_fitted_models_path=<original_fitted_models_path> A file path to the .rds objects generated by running 2_model.R.
--model_file_path=<model_file_path> A file path that describes the lavaan model to fit.
--path_out=<path_out> A file path that describes where to output the bootstrapped factor scores.
-n --num_samples An integer that describes how many bootstrap replications to fit [default: 5000].
-m --multilevel A flag, either Y or N, that describes if the lavaan model in model_file_path is meant to be multilevel [default: Y].
" -> doc

library(tidyverse)
library(lavaan)
library(parallel)
library(docopt)

opt <- docopt(doc)

#' This function extracts the latent offensive and defensive skill of all players
#' in the data used to fit the model.
#'
#' @param model A lavaan fitted model.
#' @param level If 2, return grouped estimates of latent variables 
#' (i.e. random intercept model), otherwise set to 1, which returns individual levels.
#' Will throw an error if model is not multilevel.
#' @return A tibble with columns player, off_score, and def_score.
#' @export
#'
#' @examples
#' get_latent_vars(my_lavaan_model)
get_latent_vars <- function(model, level = 2) {
	
	if (all(model@Model@multilevel == FALSE & level == 2)) {
		stop("Level = 2 but the fitted model is not multilevel. Either set level = 1 or
				 fit a multilevel model.")
	} 
	
	if (level == 2) {
		tibble(
			player = model@Data@Lp[[1]]$cluster.id[[2]],
			off_score = lavPredict(model, level = 2)[, 1],
			def_score = lavPredict(model, level = 2)[, 2]
		)
	} else {
		tibble(
			player = rep(NA, model@Data@nobs[[1]]),
			off_score = lavPredict(model, level = 1)[, 1],
			def_score = lavPredict(model, level = 1)[, 2]
		)
	}
	
}

#' Fit a lavvaan model with a given model code on a given dataset.
#'
#' @param data A relative path to a processed data file, most likely obtained from running 1_processed.R.
#' @param model_code A string describing a structural equation model.
#' @param multilevel If TRUE, fits a multilevel model. Default is TRUE. 
#' 
#' @return A list with extracted factor scores, model AIC, the actual model itself, and the data used
#' to fit the model.
#' @export
#'
#' @examples
#' fit_model_year(forward_data, my_model_code)
fit_bootstrap <- function(data, model_code, multilevel = TRUE) {
	
	if (multilevel == TRUE) {
		model <- sem(model = model_code, data = data, cluster = "player")
		scores <- get_latent_vars(model, level = 2) 
	} else {
		model <- sem(model = model_code, data = data)
		scores <- get_latent_vars(model, level = 1) %>%
			mutate(player = data$player)
	}
	
	list(factor_scores = scores, aic = AIC(model), model = model, data = data)
	
}

#' Create a bootstrapped dataset from a given dataset (that takes into consideration
#' the grouped nature of the data), for a specific seed. Samples with replacement
#' amongst clusters, but samples without replacement within each cluster.
#'
#' @param seed The seed to use for sampling within each cluster.
#' @param data The data to create bootstrap replications from.
#' @param model_file The lavaan .txt file to use.
#' @param multilevel Logical TRUE/FALSE if the model is meant to be fit as a 
#' random intercept model (default = TRUE).
#'
#' @return Factor scores generated from the bootstrapped dataset.
#' @export
#'
#' @examples
#' bootstrap_replicate(
#' 123,
#' data = my_original_data,
#' model_file = my_lavaan_txt_file,
#' multilevel = TRUE
#' )
bootstrap_replicate <- function(seed, data, model_file, multilevel = TRUE) {
	
	# Get all of the unique players in the dataset
	all_clusters <- unique(data$player)
	
	# Get all of the original counts, since in the event we sample more years than
	# we have available we just cap at the maximum.
	all_original_counts <- data %>%
		group_by(player) %>%
		count(name = "actual_counts")
	
	# Sample the clusters with replacement, then sample within each cluster without replacement.
	# If by chance the number of samples needed is larger than the actual number, cap at the total 
	# number of observations for that cluster in the actual dataset.
	set.seed(seed)
	sample_cluster_counts <- tibble(player = sample(all_clusters, replace = TRUE, size = nrow(data))) %>%
		group_by(player) %>%
		count(name = "sample_counts") %>%
		left_join(., all_original_counts, by = "player") %>%
		mutate(sample_counts = ifelse(sample_counts > actual_counts, actual_counts, sample_counts)) %>%
		left_join(., data, by = "player") %>%
		sample_n(size = sample_counts) %>%
		select(-sample_counts, -actual_counts)
	
	fit_bootstrap(
		sample_cluster_counts,
		model_code = model_file,
		multilevel = multilevel
		)$factor_scores %>%
		bind_cols(., seed_number = rep(seed, nrow(.)))
	
}

main <- function(original_fitted_models_path, model_file_path, path_out, num_samples, multilevel) {

	# Initialize objects
	multilevel_temp <- ifelse(multilevel == "Y", TRUE, FALSE)
	all_original_models <- read_rds(original_fitted_models_path)
	start_year <- as.numeric(names(all_original_models)[1]) - 1
	all_years_bootstrap = vector("list", length(all_original_models))
	model_file <- read_file(model_file_path)
	
	# If path_out doesn't exist, create it.
	if (!dir.exists(path_out)) {
		dir.create(path_out, recursive = TRUE)
	}
	
		for (i in seq_along(all_years_bootstrap)) {
	
			data <- all_original_models[[i]]$data
			
			writeLines(paste("Bootstrapping Year:", start_year + i, "for model file:", model_file_path))
			set.seed(200350623)
			seeds <- sample(1:1000000000, replace = FALSE, size = as.numeric(num_samples))
			all_years_bootstrap[[i]] <- mclapply(
				seeds,
				FUN = bootstrap_replicate,
				data = data,
				model_file = model_file,
				multilevel = multilevel_temp,
				mc.cores = detectCores() - 2
			) %>%
			bind_rows(.) %>%
			write_rds(paste0(path_out, "/", start_year + i, ".rds"))
	
		}

}

main(
	opt$original_fitted_models_path,
	opt$model_file_path,
	opt$path_out,
	opt$num_samples,
	opt$multilevel
)